---
title: 第五章 基本引用类型
date: 2020-11-23 17:52
categories:
 - 笔记
tags:
 - javascript高级程序设计
 - js
---

## Date

### `Date.parse()`

`Date.parse()`方法接收一个表示日期的字符串参数，尝试将这个字符串转换为表示该日期的毫秒数。ECMA-262第5版定义了`Date.parse()`应该支持的日期格式：

| 格式 | 示例 |
| - | - |
| 月/日/年 | 5/23/2020 |
| 月名 日,年 | May 23,2020 |
| 周几 月名 日 年 时:分:秒 时区 | Tue May 23 2020 00:00:00 GMT-0700 |
| YYYY-MM-DDTHH:mm:ss.sssZ | 2020-05-23T00:00:00 |

比如，要创建一个表示`2020-05-23`的日期对象，可以用
```javascript
let date=new Date(Date.parse("May 23,2020"))
```

如果传给的`Date.parse()`的字符串并不表示日期，则会返回`NaN`。如果直接把表示日期的字符串传给`Date`构造函数，那么`Date`会在后台调用`Date.parse()`。也就是说，下面的代码和上面的是等价的
```javascript
let date=new Date("May 23,2020")
```

### `Date.UTC()`

此方法也返回日期的毫秒表示，参数是年、月（1月是0，2月是1，以此类推）、日（1-31）、时（0-23）、分、秒和毫秒。前两个参数是必需的，其他默认值除日为1外，剩余均为0。

## 原始值包装类型

为了方便操作原始值，ECMAScript提供了3种特殊的引用类型：Boolean、Number、String。每当用到某个原始值的方法或属性时，后台都会创建一个相应的原始包装类型对象，从而暴露出各种操作方法。如：

```javascript
let s1="sth"
let s2=s1.substring(2)
```

这里呢，`s1`是一个原始值。但第二行紧接着用`s1`调用了`substring()`方法，并赋值给`s2`。我们知道原始值不是对象，所以不应该会有方法，但实际上这个例子确实如期执行了。原因呢就是`js`在后台进行了许多处理，具体说来，就是当第二行代码执行时，首先以已读模式访问`s1`，即从内存中读取变量保存的值。此时，后台会执行一些步骤：

1. 创建一个`String`类型的实例
2. 调用实例上的方法
3. 销毁实例

用代码展示：

```javascript
// 稍微改变了下原书中的代码
let s1="sth"
let temp=new String(s1)
let s2=temp.substring(2)
temp=null
// 书中代码
let s1=new String('sth')
let s2=s1.substring(2)
s1=null
```

这种行为可以让原始值拥有对象的行为。引用类型与原始包装类型的主要区别在于对象的生命周期。在通过`new`实例化引用类型后，得到的实例会在离开作用域时销毁，而自动创建的原始值包装对象则只存在于访问它的那行代码的执行期间。所以不能再运行时给原始值添加属性和方法。