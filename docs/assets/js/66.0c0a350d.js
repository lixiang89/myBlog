(window.webpackJsonp=window.webpackJsonp||[]).push([[66],{699:function(t,s,a){"use strict";a.r(s);var r=a(9),e=Object(r.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"函数参数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#函数参数"}},[t._v("#")]),t._v(" 函数参数")]),t._v(" "),a("p",[t._v("ECMAScript中所有函数的参数都是按值传递的。这意味着函数外的值会被复制到函数内部的参数中，就像从一个变量复制到另一个变量一样。原始值拷贝，引用值拷贝索引。")]),t._v(" "),a("h2",{attrs:{id:"执行-上下文"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#执行-上下文"}},[t._v("#")]),t._v(" [执行]上下文")]),t._v(" "),a("p",[t._v("上下文的概念在javascript中是很重要的。变量或函数的上下文决定了他们可以访问哪些数据，以及他们的行为。每个上下文都有一个关联的变量对象，而这个上下文中定义的所有变量和函数都存在于这个对象上。虽然无法通过代码访问，但后台处理数据会用到它。上下文在其所有代码都执行完毕后会被销毁，包括定义在他上面的变量和函数。")]),t._v(" "),a("p",[t._v("每个函数都有自己的上下文，当代码执行进入函数时，函数的上下文被推到一个上下文栈中。在函数执行完后，上下文栈会 弹出该函数上下文，将控制权交还给之前的上下文。")]),t._v(" "),a("p",[t._v("上下文中的代码咋执行的时候，会创建变量对象的一个作用域链。这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。代码正在执行的上下文的变量对象始终位于作用域链最前端。如果上下文是函数，则器活动对象用作变量对象。活动对象最初只有一个定义变量：arguments。作用域链中的下一个变量对象来自包含上下文，再下一个对象来自再下一个包换上下文。以此类推直至全局上下文。全局上下文的变量对象始终是作用域链的最后一个变量对象。")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("自备")]),t._v("：这里有点绕啊，其实记住js只有全局作用域和函数作用域即可，开始就是全局作用域（上下文）中执行，函数被调用则转入函数作用域中，此时可访问外部全局作用域中的变量（如故函数中还是有函数，继续进入，内可访问外），函数执行完毕则退出，回归全局作用域。虽然es6增加了一个块级作用域，但是却很少单独用到。一般都在for/if里捎带这用了。")])])])}),[],!1,null,null,null);s.default=e.exports}}]);